\documentclass{beamer}

%style
\mode<presentation>
\usetheme{Boadilla}

%Einstellungen der Präsentation
\title[Offensive Security]{Fuzzing Methods}
\subtitle{Offensive Security}
\author{Moritz Rupp}
\institute[MR]{Hochschule Albstadt-Sigmaringen}
\setbeamertemplate{navigation symbols}{}%remove navigation symbols
\date{SS 22}

%Beginn der Präsentation
\begin{document}
\begin{frame}
 \titlepage
\end{frame}
\begin{frame}{Contents}
 \tableofcontents
\end{frame}
\section{Fuzzing background}
\begin{frame}{Fuzzing background}
\begin{itemize}
 \item Development produces bugs, errors and unintentionally behaviour
 \item Gateway for vulnabilities and exploits
 \item Software testing tries to oppose that
 \item Many different approaches exist
\end{itemize}
\end{frame}
\subsection{Software testing}
\begin{frame}{Software testing}
 \begin{block}{Manuel testing}
  - Code reviews, manuel search for vulnabilities\\
  - Time consuming, expensive
 \end{block}
\begin{block}{Static analysis}
- Automatically examine source code bevore the programm is run\\
- Pattern analysis \\
- Control flow graph, data flow analysis\\
- Expensive tooling
\end{block}
\begin{block}{Dynamic analysis}
- Automatically examine a programm while its's been run\\
- Execute and input data in real-time\\
\end{block}
\end{frame}
\subsection{Fuzz-testing}
\begin{frame}{Fuzz-testing}

  $\Rightarrow$ Fuzz-testing is the cutting edge of dynamic analysis
  
  \begin{itemize}
   \item Input data in real-time
   \item Monitor the system behaviour
   \item Listen for exceptions
   \item Provide feedback
  \end{itemize}

\end{frame}
\section{Functionality}
\begin{frame}{Functionality}
\begin{enumerate}
 \item Identify target interfaces\\
 - portscanning, code reviews
 \item Generate inputs\\
 - mutation, generation based fuzzing
 \item Feed these inputs to the target system
 \item Monitor for exceptions
 \item Log exceptions
\end{enumerate}

\end{frame}
\begin{frame}{Basic Fuzzing application}
\begin{center}
  \includegraphics[scale=0.15]{basicfuzz.png}
\end{center}
\end{frame}
\begin{frame}{Fuzzing Methods}
 \begin{itemize}
  \item Huge landscape of applications and infrastructers\\
  - Web-applications, networks, binarys etc.\\
  $\Rightarrow$ No generall solution
  \item Different targets expect different inputs
  \item How do we generate those inputs?\\
  $\Rightarrow$ Random fuzzing\\
  $\Rightarrow$ Mutation based fuzzing\\
  $\Rightarrow$ Generation based fuzzing
 \end{itemize}

\end{frame}
\begin{frame}{Random Fuzzing}
 \begin{itemize}
 \item Earliest fuzzing approach
 \item Brute-force approach
  \item Generate pseudo random values of a given Seed
  \item Mostly usefull for black box testing\\
  - Closed source software etc.
    \item Will generate lots of rejected test-cases

 \end{itemize}

\end{frame}
\begin{frame}{Random based fuzzer}
\begin{center}
 \includegraphics[scale=0.15]{basic2.png}
 \end{center}
 \end{frame}

\begin{frame}{Mutation based Fuzzing}
\begin{itemize}
 \item Generate test-cases based on already existing data\\
 $\Rightarrow$ Record valid inputs\\
 $\Rightarrow$ Mutate these inputs
 \item Randomly or after fixed patterns
 \item No need for deep protocol knowledge
 
\end{itemize}
\end{frame}
\begin{frame}{Mutation based Fuzzer}
\begin{itemize}
 \item Flip random nummber of bits
\end{itemize}
 \includegraphics[scale=0.5]{mutatate.png}
\end{frame}
\begin{frame}
 \begin{itemize}
 \item Determine the seed correctly\\
 $\Rightarrow$ 'suchergebnisse?fuzz'
  \item Setup fixed grammars\\
  $\Rightarrow$ http/
  fuzz
 \end{itemize}
 
\end{frame}
\begin{frame}{Generation based Fuzzing}
 \begin{itemize}
  \item Generate inputs from scratch
  \item Based on the specification and format
  \item Protocol knowledge is importand
  \item Generated inputs are semi-valid
  \item Will barely generate rejected test-cases
  \item Have to be developed from scratch for every protocol/application 
  
 \end{itemize}
\end{frame}
\begin{frame}
 \begin{itemize}
   \item Assemple every part of an input sepperatly
   \item Assign rules to these indivuall parts
  \end{itemize}
 
\end{frame}
\begin{frame}{Creation rules}
\begin{table}[]
\begin{tabular}{lllll}
s\_static  &  &  set a static value  \\
s\_string  &  &  fuzz the provides string  \\
s\_delim  &  &   fuzz delimters  \\
\end{tabular}
\end{table}
\end{frame}

\begin{frame}{Fuzzing of an http request}
 \begin{center}
 \begin{table}[]
 \begin{tabular}{lllll}
 s\_static('GET')  &  &  &  \\
  s\_delim(' ')\\
 s\_delim('/')\\
    s\_string('index)\\
   s\_static('.')  &  \\
 s\_string('html')\\
 s\_delim(' ')\\
 s\_string('HTTP')&  &  & 
 \end{tabular}
 \end{table}
  
 \end{center}

\end{frame}
\begin{frame}{Tooling}
 \begin{itemize}
  \item Fuzzing is almost always executed with tooling
  \item Manuel testing only usefull in rare cases
 \end{itemize}

\end{frame}


\begin{frame}{Practical example}
 
\end{frame}
\begin{frame}{Conclusion}
 \begin{itemize}
  \item Quite complex
  \item Many findings
 \end{itemize}

\end{frame}
\begin{frame}{Quellen}
 
\end{frame}








\end{document}
